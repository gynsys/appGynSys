from typing import List, Any
from fastapi import APIRouter, Depends, HTTPException, Query, UploadFile, File
from sqlalchemy.orm import Session
from app.db.base import get_db
from app.schemas.preconsultation import PreconsultationQuestion, PreconsultationQuestionCreate, PreconsultationQuestionUpdate
from app.crud import preconsultation as crud_preconsultation
from app.core.encryption import decrypt_text
from app.api.v1.endpoints.auth import get_current_user
from app.db.models.doctor import Doctor
from app.db.models.appointment import Appointment
from typing import Annotated

router = APIRouter()

@router.get("/", response_model=List[PreconsultationQuestion])
def read_questions(
    db: Session = Depends(get_db),
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=0),
    current_user: Doctor = Depends(get_current_user)
):
    """
    Retrieve preconsultation questions for the CURRENT LOGGED IN DOCTOR (Dashboard).
    """
    questions = crud_preconsultation.get_questions(db, doctor_id=current_user.id, skip=skip, limit=limit)
    
    # Decrypt text fields if they are encrypted
    for q in questions:
        q.text = decrypt_text(q.text)
        if q.options:
            q.options = [decrypt_text(opt) for opt in q.options]
            
    return questions

@router.get("/by-appointment/{appointment_id}", response_model=List[PreconsultationQuestion])
def read_questions_by_appointment(
    appointment_id: int,
    db: Session = Depends(get_db),
):
    """
    Public Endpoint: Retrieve questions based on the Appointment's Doctor.
    Used by the Patient Flow (PreconsultaPage).
    """
    from app.db.models.appointment import Appointment
    
    appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if not appointment:
        raise HTTPException(status_code=404, detail="Appointment not found")
        
    doctor_id = appointment.doctor_id
    
    # Reuse the same CRUD logic but for the specific doctor
    questions = crud_preconsultation.get_questions(db, doctor_id=doctor_id)
    
    # Decrypt
    for q in questions:
        q.text = decrypt_text(q.text)
        if q.options:
            q.options = [decrypt_text(opt) for opt in q.options]
            
    return questions

@router.post("/", response_model=PreconsultationQuestion)
def create_question(
    *,
    db: Session = Depends(get_db),
    question_in: PreconsultationQuestionCreate,
    current_user: Doctor = Depends(get_current_user),
):
    """
    Create new preconsultation question for the current doctor.
    """
    # Note: question_in.id is likely client-generated or we should ignore it and auto-gen.
    # But current CRUD uses it. Ensuring uniqueness per doctor is tricky if ID is global string.
    # Ideally IDs should be GUIDs or composite.
    # For now, let's assume UUIDs are generated by frontend or backend.
    
    # Check for global collision (or scope check if we change PK)
    # Since ID is PK, it must be globally unique.
    question = crud_preconsultation.get_question(db, question_id=question_in.id)
    if question:
        raise HTTPException(status_code=400, detail="The question with this ID already exists")
        
    question = crud_preconsultation.create_question(db, question=question_in, doctor_id=current_user.id)
    return question

@router.put("/{question_id}", response_model=PreconsultationQuestion)
def update_question(
    *,
    db: Session = Depends(get_db),
    question_id: str,
    question_in: PreconsultationQuestionUpdate,
    current_user: Doctor = Depends(get_current_user),
):
    """
    Update a preconsultation question (Owned by current doctor).
    """
    question = crud_preconsultation.get_question(db, question_id=question_id)
    if not question:
        raise HTTPException(status_code=404, detail="Question not found")
        
    # Enforce Ownership
    if question.doctor_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to edit this question")
        
    question = crud_preconsultation.update_question(db, question_id=question_id, question=question_in)
    return question

@router.delete("/{question_id}", response_model=PreconsultationQuestion)
def delete_question(
    *,
    db: Session = Depends(get_db),
    question_id: str,
    current_user: Doctor = Depends(get_current_user),
):
    """
    Delete a preconsultation question.
    """
    question = crud_preconsultation.get_question(db, question_id=question_id)
    if not question:
        raise HTTPException(status_code=404, detail="Question not found")
        
    if question.doctor_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to delete this question")
        
    question = crud_preconsultation.delete_question(db, question_id=question_id)
    return question


@router.delete("/", response_model=dict)
def delete_all_questions(
    db: Session = Depends(get_db),
    current_user: Doctor = Depends(get_current_user),
):
    """
    Delete ALL preconsultation questions for the current doctor.
    """
    count = crud_preconsultation.delete_all_questions(db, doctor_id=current_user.id)
    return {"message": f"Deleted {count} questions"}


@router.get("/config", response_model=dict)
def get_preconsultation_config(
    appointment_id: int,
    db: Session = Depends(get_db),
):
    """
    Get configuration for the preconsultation page (Patient View).
    Includes doctor info, patient info (if available), and branding.
    """


    
    appointment = db.query(Appointment).filter(Appointment.id == appointment_id).first()
    if not appointment:
        raise HTTPException(status_code=404, detail="Appointment not found")
        
    doctor = db.query(Doctor).filter(Doctor.id == appointment.doctor_id).first()
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor not found")
        
    config = doctor.pdf_config or {}
    
    # Ensure default is True if not set
    if 'include_functional_exam' not in config:
        config['include_functional_exam'] = True
        
    # Inject doctor_id so frontend knows which questions to fetch
    config['doctor_id'] = doctor.id
    
    # Inject Branding & Personalization Data
    config['doctor_name'] = doctor.nombre_completo
    config['doctor_photo'] = doctor.photo_url or doctor.logo_url
    config['patient_name'] = appointment.patient_name
    config['patient_phone'] = appointment.patient_phone
    config['occupation'] = appointment.occupation
    config['residence'] = appointment.residence
    config['ci'] = appointment.patient_dni # Required for fetching history
    
    # Expiration / Status Data
    config['status'] = appointment.status
    
    # Smart Pre-filling: If current appointment has no answers (Recurrent Patient), try to find history
    current_answers = appointment.preconsulta_answers
    has_history_fill = False
    
    if not current_answers and appointment.patient_dni:
        # Search for latest appointment with answers for this doctor & patient
        last_filled_app = db.query(Appointment).filter(
            Appointment.doctor_id == appointment.doctor_id,
            Appointment.patient_dni == appointment.patient_dni,
            Appointment.id != appointment.id,
            Appointment.preconsulta_answers.isnot(None)
        ).order_by(Appointment.created_at.desc()).first()
        
        if last_filled_app:
            current_answers = last_filled_app.preconsulta_answers
            has_history_fill = True

    config['summary'] = current_answers
    config['appointment_date'] = appointment.appointment_date
    # 'has_answers' determines if we show the "View Answers" mode vs "Empty" mode.
    # If we found history, we treat it as having answers so they render.
    config['has_answers'] = bool(current_answers)
    config['is_historical_data'] = has_history_fill
    
    return config
